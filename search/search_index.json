{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ISCC - Enhancement Proposals (IEPs) # What is an IEP? # IEP stands for ISCC Enhancement Proposal. An IEP is a design document providing information to the ISCC community, or describing a new feature for the ISCC or its processes or environment. IEPs are a mechanism for proposing new features, for collecting community input on an issue, and for documenting design decisions. The IEP author is responsible for building consensus within the community and documenting dissenting opinions. Because the IEPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal. List of IEPs # ID Title Type Status IEP-0000 IEP Purpose and Guidelines Process Draft IEP-0001 ISCC Structure and Format Core Draft","title":"Overview"},{"location":"#iscc-enhancement-proposals-ieps","text":"","title":"ISCC - Enhancement Proposals (IEPs)"},{"location":"#what-is-an-iep","text":"IEP stands for ISCC Enhancement Proposal. An IEP is a design document providing information to the ISCC community, or describing a new feature for the ISCC or its processes or environment. IEPs are a mechanism for proposing new features, for collecting community input on an issue, and for documenting design decisions. The IEP author is responsible for building consensus within the community and documenting dissenting opinions. Because the IEPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal.","title":"What is an IEP?"},{"location":"#list-of-ieps","text":"ID Title Type Status IEP-0000 IEP Purpose and Guidelines Process Draft IEP-0001 ISCC Structure and Format Core Draft","title":"List of IEPs"},{"location":"iep-0000/","text":"IEP-0: IEP Purpose and Guidelines # IEP: 0000 Title: IEP Purpose and Guidelines Author: Titusz Pan tp@iscc.foundation Comments: https://github.com/iscc/iscc-ieps/issues/2 Status: Draft Type: Process License: BSD-2-Clause Created: 2022-08-28 Updated: 2022-09-23 1. What is an IEP? # An ISCC Enhancement Proposal (IEP) is a design document providing information to the ISCC community, or describing a new feature for the ISCC or its processes or environment. An IEP should provide a concise technical specification of a feature and a rationale for the feature. IEPs have no special status except that accorded by the community. IEPs are a mechanism for proposing new features, for collecting community input on an issue, and for documenting design decisions. The IEP author is responsible for building consensus within the community and documenting dissenting opinions. Because the IEPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal. 2. IEP audience # The typical primary audience for IEPs are the developers of ISCC implementations. However, other parts of the ISCC community may also choose to use the process (particularly for Informational IEPs) to document expected API conventions and to manage complex design coordination problems that require collaboration across multiple projects. 3. IEP workflow # The IEP process begins with a new idea for the ISCC. Each potential IEP must have a champion - someone who writes the IEP using the style and format described below, shepherds the discussions in the appropriate forums, and attempts to build community consensus around the idea. Small enhancements or patches to a particular piece of software often don't require coordination between multiple projects or implementations; these don't need an IEP and should be injected into the relevant project-specific development workflow with a patch submission to the applicable issue tracker. After investigating past work, the best way to proceed is by opening issue for discussion about the new idea. Following a discussion, the proposal should be submitted to the IEPs git repository as a pull request. This draft must be written in IEP style as described below, and named with an alias such as \"iep-johndoe-new-semantic-id\" until an editor has assigned it an IEP number (authors MUST NOT self-assign IEP numbers). When the IEP draft is complete, an IEP editor will assign the IEP a number, label it as Core, Informational, or Process, and merge the pull request to the IEPs git repository. The IEP editors will not unreasonably reject an IEP. Reasons for rejecting IEPs include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility. For an IEP to be accepted it must meet certain minimum criteria. It must be a clear and complete description of the proposed enhancement. The enhancement must represent a net improvement. The proposed implementation, if applicable, must be solid and must not complicate the protocol unduly. The IEP author may update the draft as necessary in the git repository. Updates to drafts should also be submitted by the author as pull requests. 3.1 Transferring IEP ownership # It occasionally becomes necessary to transfer ownership of IEPs to a new champion. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the IEP process, or is unreachable or not responding to email. If you are interested in assuming ownership of an IEP, send a message asking to take over, addressed to both the original author and the IEP editors. If the original author doesn't respond to email in a timely manner, the IEP editors will make a unilateral decision. 3.2 IEP editors # The current IEP editors are: Titusz Pan tp@iscc.foundation 3.3 IEP editor responsibilities # The IEP editors subscribe to the IEP issue tracker. Correspondence outside the issue tracker should be sent (or CC'd) to the IEP editors. For each new IEP that comes in an editor does the following: Read the IEP to check if it is ready: sound and complete. The ideas must make technical sense. The title should accurately describe the content. Motivation and backward compatibility (when applicable) must be addressed. Licensing terms must be acceptable for IEPs. If the IEP isn't ready, the editor will send it back to the author for revision, with specific instructions. Once the IEP is ready for the repository it should be submitted as a \"pull request\" to the IEPs git repository where it may get further feedback. The IEP editor will: Assign an IEP number in the pull request. Merge the pull request when it is ready. List the IEP in README.md. The IEP editors are intended to fulfill administrative and editorial responsibilities. The IEP editors monitor IEP changes, and update IEP headers as appropriate. 4. IEP format and structure # IEPs should be written in Markdown format. Each IEP should have the following parts: Preamble - Headers containing metadata about the IEP (see below). Abstract - A short (~200 word) description of the issue being addressed. Motivation - A motivation section is critical for IEPs that want to change pre-existing specifications. It should clearly explain why the existing specification is inadequate to address the problem that the IEP solves. This section may be omitted if the motivation is evident. Specification - The specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations. Rationale - The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion around the IEP. Backwards compatibility - All IEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The IEP must explain how the author proposes to deal with these incompatibilities. Reference implementation - A reference implementation must be completed before a Core IEP is given status Stable, but it need not be completed before the IEP is accepted. The stable implementation must include test code and documentation. Copyright - The IEP must be explicitly licensed under acceptable copyright terms see below . 4.1 IEP header preamble # Each IEP must begin with a header preamble. The headers must appear in the following order. Headers marked with \"*\" are optional and are described below. All other headers are required. IEP: <IEP number, or \"?\" before being assigned> Title: <IEP title; maximum 44 characters> Author: <list of authors' names and email addresses> Comments: <link to issue page for comments> Status: <Draft | Deferred | Withdrawn | Proposed | Rejected | Stable | Obsolete> Type: <Core | Informational | Process> License: <abbreviation for approved license(s)> Created: <date created on, in ISO 8601 (yyyy-mm-dd) format> Updated: <date updated on, in ISO 8601 (yyyy-mm-dd) format> * Replaces: <IEP number> * Superseded-By: <IEP number> The Author header lists the names and email addresses of all the authors/owners of the IEP. The format of the Author header value must be Random J. User <address@dom.ain> If there are multiple authors, each should be on a separate line. The Type header specifies the type of IEP: Core, Informational, or Process. The Created header records the date that the IEP was assigned a number. Dates should be in yyyy-mm-dd format, e.g. 2001-08-14. IEPs may have a Superseded-By header indicating that an IEP has been rendered obsolete by a later document; the value is the number of the IEP that replaces the current document. The newer IEP must have a Replaces header containing the number of the IEP that it rendered obsolete. 5. IEP Types # There are three kinds of IEPs: A Core IEP describes any change that affects most or all ISCC implementations, such as a change to the algorithms for creating ISCCs, or any change or addition that affects the interoperability of applications using the ISCC. Core IEPs consist of two parts, a design document and a reference implementation. An Informational IEP describes an ISCC design issue, or provides general guidelines or information to the ISCC community, but does not propose a new feature. Informational IEPs do not necessarily represent a ISCC community consensus or recommendation, so users and implementors are free to ignore Informational IEPs or follow their advice. A Process IEP describes a process surrounding ISCC, or proposes a change to (or an event in) a process. Process IEPs are like Core IEPs but apply to areas other than the ISCC algorithms itself. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in ISCC development. 6. IEP status # The typical paths of the status of IEPs are as follows: flowchart LR B[Draft] B --> C[Poposed] B <--> D[Deferred] B <--> E[Withdrawn] C --> F[Stable] C --> G[Rejected] F --> H[Obsolete] Champions of an IEP may decide on their own to change the status between Draft, Deferred, or Withdrawn. An IEP editor may also change the status to Deferred when no progress is being made on the IEP. An IEP may only change status from Draft to Proposed, when the author deems it is complete, has a working implementation (where applicable), and has community plans to progress it to the Stable status. IEPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in three years. Such an IEP may be changed to Draft status if the champion provides revisions that meaningfully address public criticism of the proposal, or to Proposed status if it meets the criteria required as described in the previous paragraph. An IEP may change status from Draft to Stable when it achieves rough consensus on the issue tracker and sufficient real-world adoption. Such a proposal is said to have rough consensus if it has been open to discussion on the issue tracker for at least one month, and no person maintains any unaddressed substantiated objections to it. Addressed or obstructive objections may be ignored/overruled by general agreement that they have been sufficiently addressed, but clear reasoning must be given in such circumstances. Software authors are encouraged to publish summaries of what IEPs their software supports to aid in verification of status changes. Should an IEP become actually and unambiguously adopted despite not meeting the criteria outlined here, it should still be updated to Stable status. When a Stable IEP is no longer relevant, its status may be changed to Obsolete. This change must also be objectively verifiable and/or discussed. 7. IEP licensing # New IEPs may be accepted with the following licenses. Each new IEP must identify at least one acceptable license in its preamble. The License header in the preamble must be placed befor the Created header. Each license must be referenced by their respective abbreviation given below. IEPs are not required to be exclusively licensed under approved terms, and may also be licensed under unacceptable licenses in addition to at least one acceptable license. In this case, only the acceptable license(s) should be listed in the License header. 7.1 Acceptable licenses # BSD-2-Clause: OSI-approved BSD 2-clause license BSD-3-Clause: OSI-approved BSD 3-clause license CC0-1.0: Creative Commons CC0 1.0 Universal Apache-2.0: Apache License, version 2.0 CC-BY-4.0: Creative Commons Attribution 4.0 International CC-BY-SA-4.0: Creative Commons Attribution-ShareAlike 4.0 International MIT: Expat/MIT/X11 license 8. History # This document was derived heavily from Bitcoin\u2019s BIP-0002 which in turn was derived from Python\u2019s PEP-0001. In many places text was simply copied and modified. The original authors of BIP-0002 and PEP-0001 are not responsible for its use in the ISCC Enhancement Proposals, and should not be bothered with technical questions specific to ISCC or the IEPs.","title":"IEP-0000"},{"location":"iep-0000/#iep-0-iep-purpose-and-guidelines","text":"IEP: 0000 Title: IEP Purpose and Guidelines Author: Titusz Pan tp@iscc.foundation Comments: https://github.com/iscc/iscc-ieps/issues/2 Status: Draft Type: Process License: BSD-2-Clause Created: 2022-08-28 Updated: 2022-09-23","title":"IEP-0: IEP Purpose and Guidelines"},{"location":"iep-0000/#1-what-is-an-iep","text":"An ISCC Enhancement Proposal (IEP) is a design document providing information to the ISCC community, or describing a new feature for the ISCC or its processes or environment. An IEP should provide a concise technical specification of a feature and a rationale for the feature. IEPs have no special status except that accorded by the community. IEPs are a mechanism for proposing new features, for collecting community input on an issue, and for documenting design decisions. The IEP author is responsible for building consensus within the community and documenting dissenting opinions. Because the IEPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal.","title":"1. What is an IEP?"},{"location":"iep-0000/#2-iep-audience","text":"The typical primary audience for IEPs are the developers of ISCC implementations. However, other parts of the ISCC community may also choose to use the process (particularly for Informational IEPs) to document expected API conventions and to manage complex design coordination problems that require collaboration across multiple projects.","title":"2. IEP audience"},{"location":"iep-0000/#3-iep-workflow","text":"The IEP process begins with a new idea for the ISCC. Each potential IEP must have a champion - someone who writes the IEP using the style and format described below, shepherds the discussions in the appropriate forums, and attempts to build community consensus around the idea. Small enhancements or patches to a particular piece of software often don't require coordination between multiple projects or implementations; these don't need an IEP and should be injected into the relevant project-specific development workflow with a patch submission to the applicable issue tracker. After investigating past work, the best way to proceed is by opening issue for discussion about the new idea. Following a discussion, the proposal should be submitted to the IEPs git repository as a pull request. This draft must be written in IEP style as described below, and named with an alias such as \"iep-johndoe-new-semantic-id\" until an editor has assigned it an IEP number (authors MUST NOT self-assign IEP numbers). When the IEP draft is complete, an IEP editor will assign the IEP a number, label it as Core, Informational, or Process, and merge the pull request to the IEPs git repository. The IEP editors will not unreasonably reject an IEP. Reasons for rejecting IEPs include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility. For an IEP to be accepted it must meet certain minimum criteria. It must be a clear and complete description of the proposed enhancement. The enhancement must represent a net improvement. The proposed implementation, if applicable, must be solid and must not complicate the protocol unduly. The IEP author may update the draft as necessary in the git repository. Updates to drafts should also be submitted by the author as pull requests.","title":"3. IEP workflow"},{"location":"iep-0000/#31-transferring-iep-ownership","text":"It occasionally becomes necessary to transfer ownership of IEPs to a new champion. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the IEP process, or is unreachable or not responding to email. If you are interested in assuming ownership of an IEP, send a message asking to take over, addressed to both the original author and the IEP editors. If the original author doesn't respond to email in a timely manner, the IEP editors will make a unilateral decision.","title":"3.1 Transferring IEP ownership"},{"location":"iep-0000/#32-iep-editors","text":"The current IEP editors are: Titusz Pan tp@iscc.foundation","title":"3.2 IEP editors"},{"location":"iep-0000/#33-iep-editor-responsibilities","text":"The IEP editors subscribe to the IEP issue tracker. Correspondence outside the issue tracker should be sent (or CC'd) to the IEP editors. For each new IEP that comes in an editor does the following: Read the IEP to check if it is ready: sound and complete. The ideas must make technical sense. The title should accurately describe the content. Motivation and backward compatibility (when applicable) must be addressed. Licensing terms must be acceptable for IEPs. If the IEP isn't ready, the editor will send it back to the author for revision, with specific instructions. Once the IEP is ready for the repository it should be submitted as a \"pull request\" to the IEPs git repository where it may get further feedback. The IEP editor will: Assign an IEP number in the pull request. Merge the pull request when it is ready. List the IEP in README.md. The IEP editors are intended to fulfill administrative and editorial responsibilities. The IEP editors monitor IEP changes, and update IEP headers as appropriate.","title":"3.3 IEP editor responsibilities"},{"location":"iep-0000/#4-iep-format-and-structure","text":"IEPs should be written in Markdown format. Each IEP should have the following parts: Preamble - Headers containing metadata about the IEP (see below). Abstract - A short (~200 word) description of the issue being addressed. Motivation - A motivation section is critical for IEPs that want to change pre-existing specifications. It should clearly explain why the existing specification is inadequate to address the problem that the IEP solves. This section may be omitted if the motivation is evident. Specification - The specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations. Rationale - The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion around the IEP. Backwards compatibility - All IEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The IEP must explain how the author proposes to deal with these incompatibilities. Reference implementation - A reference implementation must be completed before a Core IEP is given status Stable, but it need not be completed before the IEP is accepted. The stable implementation must include test code and documentation. Copyright - The IEP must be explicitly licensed under acceptable copyright terms see below .","title":"4. IEP format and structure"},{"location":"iep-0000/#41-iep-header-preamble","text":"Each IEP must begin with a header preamble. The headers must appear in the following order. Headers marked with \"*\" are optional and are described below. All other headers are required. IEP: <IEP number, or \"?\" before being assigned> Title: <IEP title; maximum 44 characters> Author: <list of authors' names and email addresses> Comments: <link to issue page for comments> Status: <Draft | Deferred | Withdrawn | Proposed | Rejected | Stable | Obsolete> Type: <Core | Informational | Process> License: <abbreviation for approved license(s)> Created: <date created on, in ISO 8601 (yyyy-mm-dd) format> Updated: <date updated on, in ISO 8601 (yyyy-mm-dd) format> * Replaces: <IEP number> * Superseded-By: <IEP number> The Author header lists the names and email addresses of all the authors/owners of the IEP. The format of the Author header value must be Random J. User <address@dom.ain> If there are multiple authors, each should be on a separate line. The Type header specifies the type of IEP: Core, Informational, or Process. The Created header records the date that the IEP was assigned a number. Dates should be in yyyy-mm-dd format, e.g. 2001-08-14. IEPs may have a Superseded-By header indicating that an IEP has been rendered obsolete by a later document; the value is the number of the IEP that replaces the current document. The newer IEP must have a Replaces header containing the number of the IEP that it rendered obsolete.","title":"4.1 IEP header preamble"},{"location":"iep-0000/#5-iep-types","text":"There are three kinds of IEPs: A Core IEP describes any change that affects most or all ISCC implementations, such as a change to the algorithms for creating ISCCs, or any change or addition that affects the interoperability of applications using the ISCC. Core IEPs consist of two parts, a design document and a reference implementation. An Informational IEP describes an ISCC design issue, or provides general guidelines or information to the ISCC community, but does not propose a new feature. Informational IEPs do not necessarily represent a ISCC community consensus or recommendation, so users and implementors are free to ignore Informational IEPs or follow their advice. A Process IEP describes a process surrounding ISCC, or proposes a change to (or an event in) a process. Process IEPs are like Core IEPs but apply to areas other than the ISCC algorithms itself. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in ISCC development.","title":"5. IEP Types"},{"location":"iep-0000/#6-iep-status","text":"The typical paths of the status of IEPs are as follows: flowchart LR B[Draft] B --> C[Poposed] B <--> D[Deferred] B <--> E[Withdrawn] C --> F[Stable] C --> G[Rejected] F --> H[Obsolete] Champions of an IEP may decide on their own to change the status between Draft, Deferred, or Withdrawn. An IEP editor may also change the status to Deferred when no progress is being made on the IEP. An IEP may only change status from Draft to Proposed, when the author deems it is complete, has a working implementation (where applicable), and has community plans to progress it to the Stable status. IEPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in three years. Such an IEP may be changed to Draft status if the champion provides revisions that meaningfully address public criticism of the proposal, or to Proposed status if it meets the criteria required as described in the previous paragraph. An IEP may change status from Draft to Stable when it achieves rough consensus on the issue tracker and sufficient real-world adoption. Such a proposal is said to have rough consensus if it has been open to discussion on the issue tracker for at least one month, and no person maintains any unaddressed substantiated objections to it. Addressed or obstructive objections may be ignored/overruled by general agreement that they have been sufficiently addressed, but clear reasoning must be given in such circumstances. Software authors are encouraged to publish summaries of what IEPs their software supports to aid in verification of status changes. Should an IEP become actually and unambiguously adopted despite not meeting the criteria outlined here, it should still be updated to Stable status. When a Stable IEP is no longer relevant, its status may be changed to Obsolete. This change must also be objectively verifiable and/or discussed.","title":"6. IEP status"},{"location":"iep-0000/#7-iep-licensing","text":"New IEPs may be accepted with the following licenses. Each new IEP must identify at least one acceptable license in its preamble. The License header in the preamble must be placed befor the Created header. Each license must be referenced by their respective abbreviation given below. IEPs are not required to be exclusively licensed under approved terms, and may also be licensed under unacceptable licenses in addition to at least one acceptable license. In this case, only the acceptable license(s) should be listed in the License header.","title":"7. IEP licensing"},{"location":"iep-0000/#71-acceptable-licenses","text":"BSD-2-Clause: OSI-approved BSD 2-clause license BSD-3-Clause: OSI-approved BSD 3-clause license CC0-1.0: Creative Commons CC0 1.0 Universal Apache-2.0: Apache License, version 2.0 CC-BY-4.0: Creative Commons Attribution 4.0 International CC-BY-SA-4.0: Creative Commons Attribution-ShareAlike 4.0 International MIT: Expat/MIT/X11 license","title":"7.1 Acceptable licenses"},{"location":"iep-0000/#8-history","text":"This document was derived heavily from Bitcoin\u2019s BIP-0002 which in turn was derived from Python\u2019s PEP-0001. In many places text was simply copied and modified. The original authors of BIP-0002 and PEP-0001 are not responsible for its use in the ISCC Enhancement Proposals, and should not be bothered with technical questions specific to ISCC or the IEPs.","title":"8. History"},{"location":"iep-0001/","text":"ISCC Structure and Format # IEP: 0001 Title: ISCC Structure and Format Author: Titusz Pan tp@iscc.foundation Comments: https://github.com/iscc/iscc-ieps/issues/3 Status: Draft Type: Core License: CC-BY-4.0 Created: 2022-09-23 Updated: 2022-09-23 Note This document is a DRAFT contributed as input to ISO TC 46/SC 9/WG 18 . The final version is developed at the International Organization for Standardization as ISO /AWI 24138 1. Abstract # This document describes the coding scheme for the International Standard Content Code (ISCC). 2. Motivation # The ISCC is a similarity preserving identifier for all kinds of digital content. As such the ISCC requires a universal coding scheme to meet a broad set of use cases and support different media types. Thecoding scheme for all ISCCs should be: compact interoperable modular extensible self-describing 3. General structure of ISCC # An ISCC shall be composed of an ISCC-HEADER and an ISCC-BODY. The ISCC-HEADER shall describe the MainType, SubType, Version, and Length of its ISCC-BODY. An ISCC-UNIT shall be an ISCC based on one specific algorithm. An ISCC-CODE shall be an ISCC composed of two or more different ISCC-UNITs. Figure 1 - General Structure of an ISCC 4. ISCC-HEADER # The ISCC-HEADER is a variable sized bitstream composed of an ordered sequence of the 4 header-fields MainType, SubType, Version, Length. Each header-field is a bitstream with a length between 4 and 16 bits and encodes an integer value between 0 and 4679 with the following encoding scheme: The total bit-length of a header-field shall be determined by its prefix-bits. The prefix-bits shall be followed by data-bits. The data-bits shall be interpreted as unsigned integer values plus the maximum value of the preceding range. If the total length of all header-fields in number of bits is not divisible by 8, the header shall be padded with 4 zero bits (0000) on the right side. Table 1 \u2013 Variable length ISCC-HEADER field encoding Prefix bits Number of nibbles Number of data bits Integer range 0 1 3 0-7 10 2 6 8-71 110 3 9 72-583 1110 4 12 584-4679 Header-field examples 0 = 0000 1 = 0001 \u2026 7 = 0111 8 = 1000 0000 9 = 1000 0001 The interpretation of the integer value of a header-field shall be context dependent: For the MainType and SubType fields it shall be an identifier for the designated type. For the Version field it shall be the literal version number. For the Length field of ISCC-UNITs it shall be a number used as a multiplier to calculate the bit length of the ISCC-BODY. For the Length field of ISCC-CODEs it shall be a bit-pattern encoding the combination of ISCC-UNITs and the bit-length of the ISCC-BODY. 4.1 MainTypes # The MainType header-field shall signify the type of the ISCC. Backward incompatible updates to an algorithm associated with a MainType shall be indicated by incrementing the version field of the ISCC-HEADER of the respective MainType. Note The first edition of the standard specifies initial algorithms (version 0) for all reserved MainTypes except for the SEMANTIC type which is not currently defined. Table 2 \u2013 Reserved ISCC MainTypes ID Symbol Bits Definition 0 META 0000 An ISCC-UNIT that matches on metadata similarity 1 SEMANTIC 0001 An ISCC-UNIT that matches on semantic content similarity 2 CONTENT 0010 An ISCC-UNIT that matches on perceptual content similarity 3 DATA 0011 An ISCC-UNIT that matches on data similarity 4 INSTANCE 0100 An ISCC-UNIT that matches on data identity 5 ISCC 0101 An ISCC-CODE composed of two or more headerless ISCC-UNITs for multi-modal matching 4.2 SubTypes # The MainTypes META, DATA, and INSTANCE shall have a single default SubType NONE encoded with the bits 0000. The MainTypes SEMANTIC, CONTENT, and ISCC shall have SubTypes that signify the perceptual mode. Table 3 \u2013 Reserved SubTypes for MainTypes ISCC, SEMANTIC, and CONTENT ID Symbol Bits Definition 0 TEXT 0000 Match on text similarity 1 IMAGE 0001 Match on image similarity 2 AUDIO 0010 Match on audio similarity 3 VIDEO 0011 Match on video similarity 4 MIXED 0100 Match on multi-modal similarity Table 4 \u2013 Additional Reserved SubTypes for the MainType ISCC ID Symbol Bits Definition 5 SUM 0101 Composite of ISCC-UNITs including only Data- and Instance-Code 6 NONE 0110 Composite ISCC-UNITs including Meta-, Data- and Instance-Code 4.3 Version # All ISCC-HEADERs shall have a version header-field of 0000 for the first edition of the standard. Table 5 \u2013 Reserved ISCC Versions ID Symbol Bits Definition 0 V0 0000 Initial version of ISCC-UNITs and ISCC-CODE 4.4 Length # The encoding of the Length header-field shall be specific to the MainType. 4.4.1 Length of ISCC-UNITs # For ISCC-UNITs of the MainTypes META, SEMANTIC, CONTENT, DATA, and INSTANCE the length value shall be encoded as the number of 32-bit blocks of the ISCC-BODY in addition to the minimum length of 32 bits. Table 6 \u2013 Reserved length field values (multiples of 32 bit) ID Symbol Bits Definition 0 L32 0000 Length of body is 32 bits (minimum length) 1 L64 0001 Length of body is 64 bits (default length) 2 L96 0010 Length of body is 96 bits 3 L128 0011 Length of body is 128 bits 4 L160 0100 Length of body is 160 bits 5 L192 0101 Length of body is 192 bits 6 L224 0110 Length of body is 224 bits 7 L256 0111 Length of body is 256 bits 4.4.2 Length of ISCC-CODEs # For ISCC-CODEs the length value shall designate the composition of ISCC-UNITs. The Data-Code and Instance-Code shall be mandatory 64-bit components of an ISCC-CODE. The first data-bit shall designate the presence of a 64-bit Meta-Code. The second data-bit shall designate the presence of a 64-bit Semantic-Code. The third data-bit shall designate the presence of a 64-bit Content-Code. The length of an ISCC-CODE shall be calculated as the number of active data-bits times 64 plus 128 bits of mandatory data. Table 7 \u2013 Reserved length field values (for MainType ISCC) ID Symbol Bits Definition 0 SUM 0000 No optional ISCC-UNITs. Length of body is 128 bits. 1 CDI 0001 Includes Content-Code. Length of body is 192 bits 2 SDI 0010 Includes Semantic-Code. Length of body is 192 bits 3 SCDI 0011 Includes Semantic- and Content-Code. Length of body is 256 bits 4 MDI 0100 Includes Meta-Code. Length of body is 192 bits 5 MCDI 0101 Includes Meta-Code and Content-Code. Length of body is 256 bits 6 MSDI 0110 Includes Meta-Code and Semantic-Code. Length of body is 256 bits 7 MSCDI 0111 Includes Meta-, Semantic-, and Content-Code. Length is 320 bits 5. ISCC-BODY # The preceding MainType, SubType, and Version fields shall qualify the semantics of an ISCC-BODY. The Length field shall determine the number of bits of an ISCC-BODY. 6. Encoding of ISCC # 6.1 Canonical form # The printable canonical form of an ISCC shall be its RFC 4648 Base32 encoded representation without padding and prefixed with \u201cISCC:\u201d. Canonical ISCC-CODE example ISCC:KEC43HJLPUSHVAZT66YLPUWNVACWYPIV533TRQMWF2IUQYSP5LA4CTY 6.2 URI encoding # An ISCC shall be encodable as a Uniform Resource Identifier (URI) according to RFC 3986. The URI representation shall have the format <scheme>:<path> . The URI scheme shall be the string \u201ciscc\u201d. The URI path shall be the lower-cased base32 representation of an ISCC without padding. URI encoded ISCC-CODE example iscc:kec43hjlpushvazt66ylpuwnvacwypiv533trqmwf2iuqysp5la4cty 6.3 Multiformats encoding # The ISCC shall be encodable as a multibase string. The multicodec identifier of an ISCC shall be 0xcc01 . A Multiformat representation of an ISCC shall be prefixed with a Multibase code. The encoding scheme shall be <multibase><multicodec><iscc-header><iscc-body> . ISCC shall support the following multibase encodings: Table 8 \u2013 Supported multibase encodings Encoding Code Definition base16 f hexadecimal base32 b RFC4648 case-insensitive - no padding base32hex v Match on audio similarity base58btc z base58 bitcoin base64url u RFC4648 no padding Table 9 \u2013 Examples of ISCCs in multiformats encoding Encoding Example MF base16 fcc015105cd9d2b7d247a8333f7b0b7d2cda8056c3d15eef738c1962e9148624feac1c14f MF base32 bzqavcbontuvx2jd2qmz7pmfx2lg2qblmhuk655zyyglc5ekimjh6vqobj4 MF base32hex vpg0l21edjklnq93qgcpvfc5nqb6qg1bc7kauttpoo6b2t4a8c97ulge19s MF base58btc z2Yr3BMx3Rj56fyYkNvfa19PCk4SjspQhpVWoLSGg9yXr4vUGsx MF base64url uzAFRBc2dK30keoMz97C30s2oBWw9Fe73OMGWLpFIYk_qwcFP 6.4 Readable encoding # The ISCC shall be encodable in human-readable representation. The readable representation shall encode the header-fields with their symbols and the ISCC-BODY in base16 lower-case. The header-fields and the ISCC-BODY shall be separated with hyphens. Example of human-readable ISCC-CODE ISCC-IMAGE-V0-MCDI-cd9d2b7d247a8333f7b0b7d2cda8056c3d15eef738c1962e9148624feac1c14f 7. Reference implementation # The reference implementation of this coding scheme is published in the iscc-core python package in the codec.py module.","title":"IEP-0001"},{"location":"iep-0001/#iscc-structure-and-format","text":"IEP: 0001 Title: ISCC Structure and Format Author: Titusz Pan tp@iscc.foundation Comments: https://github.com/iscc/iscc-ieps/issues/3 Status: Draft Type: Core License: CC-BY-4.0 Created: 2022-09-23 Updated: 2022-09-23 Note This document is a DRAFT contributed as input to ISO TC 46/SC 9/WG 18 . The final version is developed at the International Organization for Standardization as ISO /AWI 24138","title":"ISCC Structure and Format"},{"location":"iep-0001/#1-abstract","text":"This document describes the coding scheme for the International Standard Content Code (ISCC).","title":"1. Abstract"},{"location":"iep-0001/#2-motivation","text":"The ISCC is a similarity preserving identifier for all kinds of digital content. As such the ISCC requires a universal coding scheme to meet a broad set of use cases and support different media types. Thecoding scheme for all ISCCs should be: compact interoperable modular extensible self-describing","title":"2. Motivation"},{"location":"iep-0001/#3-general-structure-of-iscc","text":"An ISCC shall be composed of an ISCC-HEADER and an ISCC-BODY. The ISCC-HEADER shall describe the MainType, SubType, Version, and Length of its ISCC-BODY. An ISCC-UNIT shall be an ISCC based on one specific algorithm. An ISCC-CODE shall be an ISCC composed of two or more different ISCC-UNITs. Figure 1 - General Structure of an ISCC","title":"3. General structure of ISCC"},{"location":"iep-0001/#4-iscc-header","text":"The ISCC-HEADER is a variable sized bitstream composed of an ordered sequence of the 4 header-fields MainType, SubType, Version, Length. Each header-field is a bitstream with a length between 4 and 16 bits and encodes an integer value between 0 and 4679 with the following encoding scheme: The total bit-length of a header-field shall be determined by its prefix-bits. The prefix-bits shall be followed by data-bits. The data-bits shall be interpreted as unsigned integer values plus the maximum value of the preceding range. If the total length of all header-fields in number of bits is not divisible by 8, the header shall be padded with 4 zero bits (0000) on the right side. Table 1 \u2013 Variable length ISCC-HEADER field encoding Prefix bits Number of nibbles Number of data bits Integer range 0 1 3 0-7 10 2 6 8-71 110 3 9 72-583 1110 4 12 584-4679 Header-field examples 0 = 0000 1 = 0001 \u2026 7 = 0111 8 = 1000 0000 9 = 1000 0001 The interpretation of the integer value of a header-field shall be context dependent: For the MainType and SubType fields it shall be an identifier for the designated type. For the Version field it shall be the literal version number. For the Length field of ISCC-UNITs it shall be a number used as a multiplier to calculate the bit length of the ISCC-BODY. For the Length field of ISCC-CODEs it shall be a bit-pattern encoding the combination of ISCC-UNITs and the bit-length of the ISCC-BODY.","title":"4. ISCC-HEADER"},{"location":"iep-0001/#41-maintypes","text":"The MainType header-field shall signify the type of the ISCC. Backward incompatible updates to an algorithm associated with a MainType shall be indicated by incrementing the version field of the ISCC-HEADER of the respective MainType. Note The first edition of the standard specifies initial algorithms (version 0) for all reserved MainTypes except for the SEMANTIC type which is not currently defined. Table 2 \u2013 Reserved ISCC MainTypes ID Symbol Bits Definition 0 META 0000 An ISCC-UNIT that matches on metadata similarity 1 SEMANTIC 0001 An ISCC-UNIT that matches on semantic content similarity 2 CONTENT 0010 An ISCC-UNIT that matches on perceptual content similarity 3 DATA 0011 An ISCC-UNIT that matches on data similarity 4 INSTANCE 0100 An ISCC-UNIT that matches on data identity 5 ISCC 0101 An ISCC-CODE composed of two or more headerless ISCC-UNITs for multi-modal matching","title":"4.1 MainTypes"},{"location":"iep-0001/#42-subtypes","text":"The MainTypes META, DATA, and INSTANCE shall have a single default SubType NONE encoded with the bits 0000. The MainTypes SEMANTIC, CONTENT, and ISCC shall have SubTypes that signify the perceptual mode. Table 3 \u2013 Reserved SubTypes for MainTypes ISCC, SEMANTIC, and CONTENT ID Symbol Bits Definition 0 TEXT 0000 Match on text similarity 1 IMAGE 0001 Match on image similarity 2 AUDIO 0010 Match on audio similarity 3 VIDEO 0011 Match on video similarity 4 MIXED 0100 Match on multi-modal similarity Table 4 \u2013 Additional Reserved SubTypes for the MainType ISCC ID Symbol Bits Definition 5 SUM 0101 Composite of ISCC-UNITs including only Data- and Instance-Code 6 NONE 0110 Composite ISCC-UNITs including Meta-, Data- and Instance-Code","title":"4.2 SubTypes"},{"location":"iep-0001/#43-version","text":"All ISCC-HEADERs shall have a version header-field of 0000 for the first edition of the standard. Table 5 \u2013 Reserved ISCC Versions ID Symbol Bits Definition 0 V0 0000 Initial version of ISCC-UNITs and ISCC-CODE","title":"4.3 Version"},{"location":"iep-0001/#44-length","text":"The encoding of the Length header-field shall be specific to the MainType.","title":"4.4 Length"},{"location":"iep-0001/#5-iscc-body","text":"The preceding MainType, SubType, and Version fields shall qualify the semantics of an ISCC-BODY. The Length field shall determine the number of bits of an ISCC-BODY.","title":"5. ISCC-BODY"},{"location":"iep-0001/#6-encoding-of-iscc","text":"","title":"6. Encoding of ISCC"},{"location":"iep-0001/#61-canonical-form","text":"The printable canonical form of an ISCC shall be its RFC 4648 Base32 encoded representation without padding and prefixed with \u201cISCC:\u201d. Canonical ISCC-CODE example ISCC:KEC43HJLPUSHVAZT66YLPUWNVACWYPIV533TRQMWF2IUQYSP5LA4CTY","title":"6.1 Canonical form"},{"location":"iep-0001/#62-uri-encoding","text":"An ISCC shall be encodable as a Uniform Resource Identifier (URI) according to RFC 3986. The URI representation shall have the format <scheme>:<path> . The URI scheme shall be the string \u201ciscc\u201d. The URI path shall be the lower-cased base32 representation of an ISCC without padding. URI encoded ISCC-CODE example iscc:kec43hjlpushvazt66ylpuwnvacwypiv533trqmwf2iuqysp5la4cty","title":"6.2 URI encoding"},{"location":"iep-0001/#63-multiformats-encoding","text":"The ISCC shall be encodable as a multibase string. The multicodec identifier of an ISCC shall be 0xcc01 . A Multiformat representation of an ISCC shall be prefixed with a Multibase code. The encoding scheme shall be <multibase><multicodec><iscc-header><iscc-body> . ISCC shall support the following multibase encodings: Table 8 \u2013 Supported multibase encodings Encoding Code Definition base16 f hexadecimal base32 b RFC4648 case-insensitive - no padding base32hex v Match on audio similarity base58btc z base58 bitcoin base64url u RFC4648 no padding Table 9 \u2013 Examples of ISCCs in multiformats encoding Encoding Example MF base16 fcc015105cd9d2b7d247a8333f7b0b7d2cda8056c3d15eef738c1962e9148624feac1c14f MF base32 bzqavcbontuvx2jd2qmz7pmfx2lg2qblmhuk655zyyglc5ekimjh6vqobj4 MF base32hex vpg0l21edjklnq93qgcpvfc5nqb6qg1bc7kauttpoo6b2t4a8c97ulge19s MF base58btc z2Yr3BMx3Rj56fyYkNvfa19PCk4SjspQhpVWoLSGg9yXr4vUGsx MF base64url uzAFRBc2dK30keoMz97C30s2oBWw9Fe73OMGWLpFIYk_qwcFP","title":"6.3 Multiformats encoding"},{"location":"iep-0001/#64-readable-encoding","text":"The ISCC shall be encodable in human-readable representation. The readable representation shall encode the header-fields with their symbols and the ISCC-BODY in base16 lower-case. The header-fields and the ISCC-BODY shall be separated with hyphens. Example of human-readable ISCC-CODE ISCC-IMAGE-V0-MCDI-cd9d2b7d247a8333f7b0b7d2cda8056c3d15eef738c1962e9148624feac1c14f","title":"6.4 Readable encoding"},{"location":"iep-0001/#7-reference-implementation","text":"The reference implementation of this coding scheme is published in the iscc-core python package in the codec.py module.","title":"7. Reference implementation"},{"location":"includes/abbreviations/","text":"","title":"Abbreviations"}]}